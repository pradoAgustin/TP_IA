package backend;

import java.awt.Color;
import java.util.ArrayList;

import javax.xml.bind.Marshaller.Listener;

public class Board {
	private Cell[][] matrix;
	private int paintedSquares;
	private int unpaintedSquares;
	private Dot[] currentDots;
	private int rowSize;
	private int colSize;
	int calls;

	private final static Direction[][] bestDirection = new Direction[][] {
	/* 0 */{ Direction.UP, Direction.LEFT, Direction.DOWN, Direction.RIGHT },
	/* 1 */{ Direction.UP, Direction.LEFT, Direction.RIGHT, Direction.DOWN },
	/* 2 */{ Direction.UP, Direction.RIGHT, Direction.DOWN, Direction.LEFT },
	/* 3 */{ Direction.LEFT, Direction.UP, Direction.DOWN, Direction.RIGHT },
	/* 4 */{ Direction.RIGHT, Direction.UP, Direction.DOWN, Direction.LEFT },
	/* 5 */{ Direction.DOWN, Direction.LEFT, Direction.UP, Direction.RIGHT },
	/* 6 */{ Direction.DOWN, Direction.LEFT, Direction.RIGHT, Direction.UP },
	/* 7 */{ Direction.DOWN, Direction.RIGHT, Direction.UP, Direction.LEFT } };

	public Board(Cell[][] board, Dot[] dots) {
		this.matrix = board;
		this.currentDots = dots;
		setRowSize(matrix.length);
		setColSize(matrix[0].length);
		calls = 0;

	}

	public Cell[][] getMatrix() {
		return this.matrix;
	}

	public boolean isOrigin(int row, int col, int color) {
		for (Dot d : currentDots) {
			if (d.getColor() == color) {
				return d.getStart().col == col && d.getStart().row == row;
			}
		}
		return false;
	}

	public boolean isEnd(int row, int col, int color) {
		for (Dot d : currentDots) {
			if (d.getColor() == color) {
				return d.getEnd().col == col && d.getEnd().row == row;
			}
		}
		return false;
	}

	public int getRowSize() {
		return rowSize;
	}

	public void setRowSize(int rowSize) {
		this.rowSize = rowSize;
	}

	public int getColSize() {
		return colSize;
	}

	public void setColSize(int colSize) {
		this.colSize = colSize;
	}

	/**
	 * solves the board for the exact solution
	 * */

	public Board solve(Listener listener) {
		Dot initialDot = currentDots[0];
		Board solution = new Board(null, currentDots);
		this.paintedSquares = 0;
		solve(initialDot.getColor(), null, initialDot.getStart(), 0, solution,
				listener);
		return solution.matrix == null ? null : solution;
	}

	private boolean solve(int color, Position previousPos, Position currentPos,
			int index, Board solution, Listener listener) {
		int currentPositionColor;

		/* check the actual posicion of the point */
		if ((matrix.length <= currentPos.row || currentPos.row < 0)
				|| (matrix[0].length <= currentPos.col || currentPos.row < 0)) {
			return false;
		}
		currentPositionColor = matrix[currentPos.row][currentPos.col]
				.getColor();
		if (color == currentPositionColor) {
			if (previousPos == null) {
				return false;
			}
			if (currentPos.equals(currentDots[index].getEnd())) {
				paintedSquares++;
				if (currentDots.length == index + 1) {
					saveSolution(this, solution);
					if (unpaintedSquares == 0) {
						return true;
					}
				} else {
					Dot nextDot = currentDots[index + 1];
					return solve(nextDot.getColor(), null, nextDot.getStart(),
							index + 1, solution, listener);
				}
				paintedSquares--;
			}
			return false;
		}else if(currentPositionColor!=-1){
			return false;
		}
		matrix[currentPos.row][currentPos.col].setColor(color);
		paintedSquares++;
		 /*secciï¿½n para imprimir con intervalos de a 100ms*/
        if(listener!=null) listener.printToScreen();

        for(Direction d : this.optimalDir[0]){
            if( !(nextPos = currentPos.getPosition(d)).equals(prevPos) ){
                if(solve(color, currentPos, nextPos, index, solution,listener)) return true;
            }
        }
        this.matrix[currentPos.row][currentPos.col].color = currentPosColor;
        this.paintedCells--;
        return false;

	}

	private void saveSolution(Board board, Board solution) {
		// TODO Auto-generated method stub

	}

	
	
	
	
}
